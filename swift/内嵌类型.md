# 内嵌类型

枚举通常用于实现特定类或结构体的功能。类似的，它也可以在更加复杂的类型环境中方便的定义通用类和结构体。为实现这种功能，Swift 允许你定义*内嵌类型*，借此在支持类型的定义中嵌套枚举、类、或结构体。

若要在一种类型中嵌套另一种类型，在其支持类型的大括号内定义即可。可以根据需求多级嵌套数个类型。

- 内嵌类型的使用

  ```
  struct BlackjackCard {
   
      // nested Suit enumeration
      enum Suit: Character {
          case spades = "♠", hearts = "♡", diamonds = "♢", clubs = "♣"
      }
   
      // nested Rank enumeration
      enum Rank: Int {
          case two = 2, three, four, five, six, seven, eight, nine, ten
          case jack, queen, king, ace
          struct Values {
              let first: Int, second: Int?
          }
          var values: Values {
              switch self {
              case .ace:
                  return Values(first: 1, second: 11)
              case .jack, .queen, .king:
                  return Values(first: 10, second: nil)
              default:
                  return Values(first: self.rawValue, second: nil)
              }
          }
      }
   
      // BlackjackCard properties and methods
      let rank: Rank, suit: Suit
      var description: String {
          var output = "suit is \(suit.rawValue),"
          output += " value is \(rank.values.first)"
          if let second = rank.values.second {
              output += " or \(second)"
          }
          return output
      }
  }
  
  let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)
  print("theAceOfSpades: \(theAceOfSpades.description)")
  // Prints "theAceOfSpades: suit is ♠, value is 1 or 11"
  ```

- 引用内嵌类型

要在定义外部使用内嵌类型，只需在其前缀加上内嵌了它的类的类型名即可：

```swift
let heartsSymbol = BlackjackCard.Suit.hearts.rawValue
// heartsSymbol is "♡"
```

对于上面的栗子来说，可以使 Suit 、 Rank 和 Values 的名字尽可能的短，因为它们的名字由定义时的上下文自然限定。

