# 闭包

- [闭包表达式](http://wiki.jikexueyuan.com/project/swift/chapter2/07_Closures.html#closure_expressions)
- [尾随闭包](http://wiki.jikexueyuan.com/project/swift/chapter2/07_Closures.html#trailing_closures)
- [值捕获](http://wiki.jikexueyuan.com/project/swift/chapter2/07_Closures.html#capturing_values)
- [闭包是引用类型](http://wiki.jikexueyuan.com/project/swift/chapter2/07_Closures.html#closures_are_reference_types)
- [逃逸闭包](http://wiki.jikexueyuan.com/project/swift/chapter2/07_Closures.html#escaping_closures)
- [自动闭包](http://wiki.jikexueyuan.com/project/swift/chapter2/07_Closures.html#autoclosures)



---------------------

- 闭包表达式

  ```
  { (parameters) -> return type in
      statements
  }
  ```

  ```
  reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
  
  reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
  
  
  reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
  
  
  reversedNames = names.sorted(by: { $0 > $1 } )
  
  
  reversedNames = names.sorted(by: >)
  ```

  

- 尾随闭包

  如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用*尾随闭包*来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：

  ```
  func someFunctionThatTakesAClosure(closure: () -> Void) {
      // 函数体部分
  }
  
  // 以下是不使用尾随闭包进行函数调用
  someFunctionThatTakesAClosure(closure: {
      // 闭包主体部分
  })
  
  // 以下是使用尾随闭包进行函数调用
  someFunctionThatTakesAClosure() {
      // 闭包主体部分
  }
  ```

  ```
  reversedNames = names.sorted() { $0 > $1 }
  ```

  

- 值捕获

  闭包可以在其被定义的上下文中*捕获*常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。

  Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。

- 闭包是饮用类型的

- 逃逸闭包

  闭包可以在其被定义的上下文中*捕获*常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。

  Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。

  ```
  var completionHandlers: [() -> Void] = []
  func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
      completionHandlers.append(completionHandler)
  }
  
  func someFunctionWithNonescapingClosure(closure: () -> Void) {
      closure()
  }
  
  class SomeClass {
      var x = 10
      func doSomething() {
          someFunctionWithEscapingClosure { self.x = 100 }
          someFunctionWithNonescapingClosure { x = 200 }
      }
  }
  
  let instance = SomeClass()
  instance.doSomething()
  print(instance.x)
  // 打印出 "200"
  
  completionHandlers.first?()
  print(instance.x)
  // 打印出 "100"
  
  
  ```

  

- 自动闭包

  *自动闭包*是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。