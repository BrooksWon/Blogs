*泛型代码*让你能根据你所定义的要求写出可以用于任何类型的灵活的、可复用的函数。你可以编写出可复用、意图表达清晰、抽象的代码。

泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。实际上，甚至你都没有意识到在*语言指南*中一直在使用泛型。例如，Swift 的 Array 和 Dictionary 类型都是泛型集合。你可以创建一个容纳 Int 值的数组，或者容纳String 值的数组，甚至容纳任何 Swift 可以创建的其他类型的数组。同样，你可以创建一个存储任何指定类型值的字典，而且类型没有限制。

- 泛型解决的问题

  泛型可以使问题的解决方案更通用，比如：

  下面的 swapTwoInts(_:_:) 是一个标准的非泛型函数，用于交换两个 Int 值：

  ```
  func swapTwoInts(_ a: inout Int, _ b: inout Int) {
      let temporaryA = a
      a = b
      b = temporaryA
  }
  ```

  swapTwoInts(_:_:) 函数很实用，但是它只能用于 Int 值。如果你想交换两个 String 值，或者两个 Double 值，你只能再写更多的函数，比如下面的 swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 函数：

  ```
  func swapTwoStrings(_ a: inout String, _ b: inout String) {
      let temporaryA = a
      a = b
      b = temporaryA
  }
  func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
      let temporaryA = a
      a = b
      b = temporaryA
  }
  
  
  func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
      let temporaryA = a
      a = b
      b = temporaryA
  }
  ```

  你可能已经注意到了， swapTwoInts(_:_:) 、 swapTwoStrings(_:_:) 、 swapTwoDoubles(_:_:) 函数体是一样的。唯一的区别是它们接收值类型不同（ Int 、 String 和 Double ）。

  写一个可以交换*任意*类型值的函数会更实用、更灵活。泛型代码让你能写出这样的函数。（下文中定义了这些函数的泛型版本。）

- 泛型函数

  *泛型函数*可以用于任何类型。这里是上面提到的 swapTwoInts(_:_:) 函数的泛型版本，叫做 swapTwoValues(_:_:) ：

  ```
  func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
      let temporaryA = a
      a = b
      b = temporaryA
  }
  ```

  泛型版本的函数用了一个*占位符*类型名（这里叫做 T ），而不是一个*实际的*类型名（比如 Int 、 String 或 Double ）。占位符类型名没有声明 T 必须是什么样的，但是它*确实*说了 a 和 b 必须都是同一个类型 T ，或者说都是 T 所表示的类型。替代 T 实际使用的类型将在每次调用 swapTwoValues(_:_:) 函数时决定。

  其他的区别是泛型函数名（ swapTwoValues(_:_:) ）后面有包在尖括号（ <T> ）里的占位符类型名（ T ）。尖括号告诉Swift， T 是一个 swapTwoValues(_:_:) 函数定义里的占位符类型名。因为 T 是一个占位符，Swift 不会查找真的叫 T 的类型。

  现在，可以用调用 swapTwoInts 的方式来调用 swapTwoValues(_:_:) 函数，除此之外，可以给函数传递两个*任意*类型的值，只要两个实参的类型一致即可。每次调用 swapTwoValues(_:_:) ，用于 T 的类型会根据传入函数的值类型自动推断。

  ```
  var someInt = 3
  var anotherInt = 107
  swapTwoValues(&someInt, &anotherInt)
  // someInt is now 107, and anotherInt is now 3
   
  var someString = "hello"
  var anotherString = "world"
  swapTwoValues(&someString, &anotherString)
  // someString is now "world", and anotherString is now "hello"
  ```

- ## 类型形式参数

  上面的 swapTwoValues(_:_:) 中，占位符类型 T 就是一个*类型形式参数*的例子。类型形式参数指定并且命名一个占位符类型，紧挨着写在函数名后面的一对尖括号里（比如 <T> ）。

  一旦你指定了一个类型形式参数，你就可以用它定义一个函数形式参数（比如 swapTwoValues(_:_:) 函数中的形式参数 a 和b ）的类型，或者用它做函数返回值类型，或者做函数体中类型标注。在不同情况下，用调用函数时的*实际*类型来替换类型形式参数。（上面的 swapTwoValues(_:_:) 例子中，第一次调用函数的时候用 Int 替换了 T ，第二次调用是用 String 替换的。）

  你可以通过在尖括号里写多个用逗号隔开的类型形式参数名，来提供更多类型形式参数。

- ## 命名类型形式参数

  大多数情况下，类型形式参数的名字要有描述性，比如 Dictionary<Key, Value> 中的 Key  和 Value ，借此告知读者类型形式参数和泛型类型、泛型用到的函数之间的关系。但是，他们之间的关系没有意义时，一般按惯例用单个字母命名，比如T 、 U 、 V ，比如上面的 swapTwoValues(_:_:) 函数中的 T 。

  > 类型形式参数永远用大写开头的驼峰命名法（比如 T 和 MyTypeParameter ）命名，以指明它们是一个类型的占位符，不是一个值。

- ## 泛型类型

  除了泛型函数，Swift允许你定义自己的*泛型类型*。它们是可以用于*任意*类型的自定义类、结构体、枚举，和 Array 、Dictionary 方式类似。

  本章将向你展示如何写出一个叫做 Stack 的泛型集合类型。栈是值的有序集合，和数组类似，但是比 Swift 的 Array 类型有更严格的操作限制。数组允许在其中任何位置插入和移除元素。但是，栈的新元素只能添加到集合的末尾（这就是所谓的*压栈*）。同样，栈只允许从集合的末尾移除元素（这就是所谓的*出栈*）。

  ```
  //这里是如何写一个非泛型版本的栈，这种情况是一个 Int 值的栈：
  
  struct IntStack {
      var items = [Int]()
      mutating func push(_ item: Int) {
          items.append(item)
      }
      mutating func pop() -> Int {
          return items.removeLast()
      }
  }
  
  var stack = IntStack()
  stack.push(1)
  stack.push(2)
  stack.push(3)
  print(stack.pop())
  
  
  //这里有一个相同代码的泛型版本：
  
  struct Stack<Element> {
      var items = [Element]()
      mutating func push(_ item: Element) {
          items.append(item)
      }
      mutating func pop() -> Element {
          return items.removeLast()
      }
  }
  
  
  var stackOfStrings = Stack<String>()
  stackOfStrings.push("uno")
  stackOfStrings.push("dos")
  stackOfStrings.push("tres")
  stackOfStrings.push("cuatro")
  // the stack now contains 4 strings
  ```

- ## 扩展一个泛型类型

  当你扩展一个泛型类型时，不需要在扩展的定义中提供类型形式参数列表。*原始*类型定义的类型形式参数列表在扩展体里仍然有效，并且原始类型形式参数列表名称也用于扩展类型形式参数。

  下面的例子扩展了泛型 Stack 类型，向其中添加一个叫做 topItem 的只读计算属性，不需要从栈里移除就能返回顶部的元素：

  ```
  extension Stack {
      var topItem: Element? {
          return items.isEmpty ? nil : items[items.count - 1]
      }
  }
  ```

- ## 类型约束

- ### 类型约束语法

  在一个类型形式参数名称后面放置一个类或者协议作为形式参数列表的一部分，并用冒号隔开，以写出一个类型约束。下面展示了一个泛型函数类型约束的基本语法（和泛型类型的语法相同）：

  ```
  func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
      // function body goes here
  }
  ```

  上面的假想函数有两个形式参数。第一个类型形式参数， T ，有一个类型约束要求 T 是 SomeClass 的子类。第二个类型形式参数， U ，有一个类型约束要求 U 遵循 SomeProtocol 协议。

- ## 关联类型

  定义一个协议时，有时在协议定义里声明一个或多个关联类型是很有用的。*关联类型*给协议中用到的类型一个占位符名称。直到采纳协议时，才指定用于该关联类型的实际类型。关联类型通过 associatedtype 关键字指定

  - ### 关联类型的应用

    这里是一个叫做 Container 的示例协议，声明了一个叫做 ItemType 的关联类型：

    ```
    protocol Container {
        associatedtype ItemType
        mutating func append(_ item: ItemType)
        var count: Int { get }
        subscript(i: Int) -> ItemType { get }
    }
    ```

    这是前面非泛型版本的 IntStack ，使其遵循 Container 协议：

    ```
    struct IntStack: Container {
        // original IntStack implementation
        var items = [Int]()
        mutating func push(_ item: Int) {
            items.append(item)
        }
        mutating func pop() -> Int {
            return items.removeLast()
        }
        // conformance to the Container protocol
        typealias ItemType = Int
        mutating func append(_ item: Int) {
            self.push(item)
        }
        var count: Int {
            return items.count
        }
        subscript(i: Int) -> Int {
            return items[i]
        }
    }
    ```

    你也可以做一个遵循 Container 协议的泛型 Stack 类型：

    ```
    struct Stack<Element>: Container {
        // original Stack<Element> implementation
        var items = [Element]()
        mutating func push(_ item: Element) {
            items.append(item)
        }
        mutating func pop() -> Element {
            return items.removeLast()
        }
        // conformance to the Container protocol
        mutating func append(_ item: Element) {
            self.push(item)
        }
        var count: Int {
            return items.count
        }
        subscript(i: Int) -> Element {
            return items[i]
        }
    }
    ```

    这次，类型形式参数 Element 用于 append(_:) 方法的 item 形式参数和下标的返回类型。因此，对于这个容器，Swift可以推断出 Element 是适用于 ItemType 的类型。

  - ### 给关联类型添加约束

    你可以在协议里给关联类型添加约束来要求遵循的类型满足约束。比如说，下面的代码定义了一个版本的 Container ，它要求容器中的元素都是可判等的。

    ```
    protocol Container {
        associatedtype Item: Equatable
        mutating func append(_ item: Item)
        var count: Int { get }
        subscript(i: Int) -> Item { get }
    }
    ```

    要遵循这个版本的  ，容器的Item  协议。Container  必须遵循Equatable。

  - ### 在关联类型约束里使用协议

    协议可以作为它自身的要求出现。比如说，这里有一个协议细化了 Container 协议，添加了一个 suffix(_:) 方法。suffix(_:) 方法返回容器中从后往前给定数量的元素，把它们存储在一个 Suffix 类型的实例里。

    ```
    protocol SuffixableContainer: Container {
        associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
        func suffix(_ size: Int) -> Suffix
    }
    ```

  - ### 扩展现有类型来指定关联类型

    ```
    extension Array: Container {}
    ```

- ## 泛型Where分句

  如[类型约束](https://www.cnswift.org/generics?preview_id=72&preview_nonce=3b6769f6db&_thumbnail_id=-1&preview=true#spl-7)中描述的一样，类型约束允许你在泛型函数或泛型类型相关的类型形式参数上定义要求。

  类型约束在为关联类型定义要求时也很有用。通过定义一个*泛型Where分句*来实现。泛型 Where 分句让你能够要求一个关联类型必须遵循指定的协议，或者指定的类型形式参数和关联类型必须相同。泛型 Where 分句以 Where 关键字开头，后接关联类型的约束或类型和关联类型一致的关系。泛型 Where 分句写在一个类型或函数体的左半个大括号前面。

  下面的例子定义了一个叫做 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有元素都匹配，函数返回布尔值 ture ，否则返回 false 。

  被检查的两个容器不一定是相同类型的（尽管它们可以是），但是它们的元素类型必须相同。这个要求通过类型约束和泛型Where 分句一起体现：

  ```
  func allItemsMatch<C1: Container, C2: Container>
      (_ someContainer: C1, _ anotherContainer: C2) -> Bool
      where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {
          
          // Check that both containers contain the same number of items.
          if someContainer.count != anotherContainer.count {
              return false
          }
          
          // Check each pair of items to see if they are equivalent.
          for i in 0..<someContainer.count {
              if someContainer[i] != anotherContainer[i] {
                  return false
              }
          }
          
          // All items match, so return true.
          return true
  }
  ```

- ## 带有泛型 Where 分句的扩展

  你同时也可以使用泛型的 where 分句来作为扩展的一部分。下面的泛型 Stack 结构体的扩展了先前的栗子，添加了一个isTop(_:) 方法。

  ```
  extension Stack where Element: Equatable {
      func isTop(_ item: Element) -> Bool {
          guard let topItem = items.last else {
              return false
          }
          return topItem == item
      }
  }
  ```

  上边例子中的泛型 where 分句要求 Item 遵循协议，但你同样可以写一个泛型 where 分句来要求 Item 为特定类型。比如：

  ```
  extension Container where Item == Double {
      func average() -> Double {
          var sum = 0.0
          for index in 0..<count {
              sum += self[index]
          }
          return sum / Double(count)
      }
  }
  ```

  你可以在一个泛型 where 分句中包含多个要求来作为扩展的一部分，就如同你在其它地方写的泛型 where 分句一样。每一个需求用逗号分隔。

- ## 关联类型的泛型 Where 分句

  你可以在关联类型中包含一个泛型 where 分句。比如说，假定你想要做一个包含遍历器的 Container ，比如标准库中Sequence 协议那样。那么你会这么写：

  ```
  protocol Container {
      associatedtype Item
      mutating func append(_ item: Item)
      var count: Int { get }
      subscript(i: Int) -> Item { get }
      
      associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
      func makeIterator() -> Iterator
  }
  ```

  对于一个继承自其他协议的协议来说，你可以通过在协议的声明中包含泛型 where 分句来给继承的协议中关联类型添加限定。比如说，下面的代码声明了一个 ComparableContainer 协议，它要求 Item 遵循 Comparable ：

  ```
  protocol ComparableContainer: Container where Item: Comparable { }
  ```

- ## 泛型下标

  下标可以是泛型，它们可以包含泛型 where 分句。你可以在 subscript 后用尖括号来写类型占位符，你还可以在下标代码块花括号前写泛型 where 分句。举例来说：

  ```
  extension Container {
      subscript<Indices: Sequence>(indices: Indices) -> [Item]
          where Indices.Iterator.Element == Int {
              var result = [Item]()
              for index in indices {
                  result.append(self[index])
              }
              return result
      }
  }
  ```

  