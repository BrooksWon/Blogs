# 属性

- [存储属性](http://wiki.jikexueyuan.com/project/swift/chapter2/10_Properties.html#stored_properties)
- [计算属性](http://wiki.jikexueyuan.com/project/swift/chapter2/10_Properties.html#computed_properties)
- [属性观察器](http://wiki.jikexueyuan.com/project/swift/chapter2/10_Properties.html#property_observers)
- [全局变量和局部变量](http://wiki.jikexueyuan.com/project/swift/chapter2/10_Properties.html#global_and_local_variables)
- [类型属性](http://wiki.jikexueyuan.com/project/swift/chapter2/10_Properties.html#type_properties)



*属性*将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。

存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接作用于类型本身，这种属性称为类型属性。

另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。



- 存储属性

- 计算属性

  ```
  struct AlternativeRect {
      var origin = Point()
      var size = Size()
      var center: Point {
          get {
              let centerX = origin.x + (size.width / 2)
              let centerY = origin.y + (size.height / 2)
              return Point(x: centerX, y: centerY)
          }
          set {
              origin.x = newValue.x - (size.width / 2)
              origin.y = newValue.y - (size.height / 2)
          }
      }
  }
  ```

- 属性观察器

  属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。

  你可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。 属性重写请参考[重写](http://wiki.jikexueyuan.com/project/swift/chapter2/13_Inheritance.html#overriding)。

  可以为属性添加如下的一个或全部观察器：

  - `willSet` 在新的值被设置之前调用
  - `didSet` 在新的值被设置之后立即调用

  `willSet` 观察器会将新的属性值作为常量参数传入，在 `willSet` 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 `newValue` 表示。

  同样，`didSet` 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 `oldValue`。如果在 `didSet` 方法中再次对该属性赋值，那么新值会覆盖旧的值。

- 局部变量和全局变量

- 类型属性

  使用关键字 `static` 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 `class` 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：